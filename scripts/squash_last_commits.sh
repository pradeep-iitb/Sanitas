#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<EOF
Usage: $(basename "$0") [-n N] [-m MESSAGE] [-b BACKUP] [--push] [-y]

Squash the previous N commits on the current branch into a single commit.

Options:
  -n N        Number of commits to squash (default: 30)
  -m MESSAGE  Commit message for the squashed commit (default: autogenerated)
  -b BACKUP   Name for backup branch (default: backup-squash-<N>-<ts>)
  --push      Force-push the rewritten branch to origin (uses --force-with-lease)
  -y          Automatic yes for push confirmation
  -h          Show this help

This script will:
  - require a clean working tree (no unstaged or uncommitted changes)
  - create a local backup branch before rewriting
  - perform a soft reset to HEAD~N and create a single commit with all changes
  - optionally force-push the current branch to origin

WARNING: This rewrites history. You will need to coordinate with collaborators.
EOF
}

N=30
MESSAGE=""
PUSH=0
AUTOMATIC_NO_PROMPT=0
BACKUP=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -n) N="$2"; shift 2 ;;
    -m) MESSAGE="$2"; shift 2 ;;
    -b) BACKUP="$2"; shift 2 ;;
    --push) PUSH=1; shift ;;
    -y) AUTOMATIC_NO_PROMPT=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1"; usage; exit 2 ;;
  esac
done

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Not inside a git repository. Run this from the repo root." >&2
  exit 2
fi

BRANCH="$(git rev-parse --abbrev-ref HEAD)"
if [[ -z "$BRANCH" || "$BRANCH" = "HEAD" ]]; then
  echo "You are in a detached HEAD. Please check out a branch first." >&2
  exit 2
fi

if [[ -z "$BACKUP" ]]; then
  ts=$(date +%s)
  BACKUP="backup-squash-${N}-${ts}"
fi

if [[ -n "$(git status --porcelain)" ]]; then
  echo "Working tree is not clean. Please commit or stash changes first." >&2
  git status --short
  exit 3
fi

commit_count=$(git rev-list --count HEAD)
if (( commit_count < N )); then
  echo "Repository has only $commit_count commits; cannot squash last $N commits." >&2
  exit 4
fi

echo "Branch: $BRANCH"
echo "Creating backup branch: $BACKUP"
git branch "$BACKUP"

echo "About to squash last $N commits into one on branch $BRANCH."
if [[ -z "$MESSAGE" ]]; then
  MESSAGE="Squash: combine last $N commits"
fi

echo "Resetting soft to HEAD~$N"
git reset --soft "HEAD~$N"

echo "Creating squashed commit"
GIT_COMMITTER_DATE="$(date --iso-8601=seconds)" git commit -m "$MESSAGE"

echo "New top commits:" 
git --no-pager log -n 5 --pretty=format:'%h %ad %an <%ae> %s' --date=iso

if (( PUSH )); then
  if (( AUTOMATIC_NO_PROMPT )); then
    confirm=Y
  else
    read -r -p "Push rewritten branch to origin/$BRANCH with --force-with-lease? (y/N) " confirm
  fi
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    echo "Force-pushing to origin/$BRANCH (using --force-with-lease)"
    git push origin "HEAD:$BRANCH" --force-with-lease
    echo "Pushed." 
  else
    echo "Skipping push. You can push with: git push origin HEAD:$BRANCH --force-with-lease"
  fi
else
  echo "No push requested. To publish changes, run: git push origin HEAD:$BRANCH --force-with-lease"
fi

echo "Done. A backup branch named '$BACKUP' was created pointing to the previous state."
